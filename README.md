# 5 ~ 6주차 미션: Next-Netflix

<br>

## [🪄 결과물](https://next-netflix-20th-onedwo.vercel.app)

### 🩵 구현 기능

- 피그마 화면 구현

- SSR을 적용해서 구현

- Open api를 사용해서 데이터 패칭을 진행

- 동적 라우팅으로 상세 페이지 구현

- 실시간 키워드 검색으로 검색 페이지 구

### 🩵 느낀 점

**[송유선]** 협업으로 진행하는 첫 스터디 과제라 우여곡절이 많았던 것 같다. 초기 세팅을 맞출 때부터 오류가 많이 나서 당황했지만, 같이 극복하는 과정에서 배운 것도 많았다. (public 폴더의 위치에 따른 경로 설정부터, next.js 의 파일 구조까지...) 이번에 Next.js, Tailwind.css, OpenAPI 등 처음 써 보는 게 너무 많아서 더 애를 먹었던 것 같다. 효율적인 코드를 작성하고 싶었는데 맞게 작성하고 있는지 확신할 수가 없어서 답답했다.. 나는 main과 detail 페이지를 작업했는데, 고민을 했던 부분 중 하나는 랜딩에서 혼합되어 있는 컨텐츠들의 상세 페이지를 어떻게 라우팅할지였다. 종류가 movie랑 tv로 섞여 있는데 getContents에서 불러오는 정보에는 영화인지 티비 프로그램인지 알려주는 부분이 없었지만 detail 정보를 요청하기 위해서는 id 앞에 종류를 써야 했다. 그래서 아예 상세 페이지를 라우팅할 때 미리 정의한 media_type을 (`const media_type = category.includes('/tv') ? 'tv' : 'movie';`) id와 함께 주소에 넣고 넘긴 뒤 params로 작업했는데... 버셀에서 배포할 때 오류가 났다..^^ 로컬에선 아무 문제 없었는데, 배포 시에는 더 엄격한 타입 검증을 해서 그런 것 같다. params 말고 props 각각 타입 지정해보기도 하고 여러 방법을 써 봤는데 아직 만족스럽게 해결하지 못 했다... (결국 eslintrc 에 any 쓸 수 있도록 규칙 추가함...) 이 부분은 다음 주에 가능하면 좀 더 괜찮은 방향으로 수정해보고 싶다. 추가로, 이번에는 스켈레톤이나 로딩 중에 보여줄 화면을 따로 만들지 못했는데 다음 주에 간단하게라도 추가해보고 싶다.
<br/><br/>
**[최지원]** Next를 처음 써보아서 초반에는 리액트와 가장 크게 다른 부분인 라우팅 방식, 서버 컴포넌트의 활용에 대해 알아본 후 시작했었습니다. 초기 세팅을 잘 해두어야 뒤에 가서 번거로움을 줄일 수 있다는 깨달음을 그 어떤 때보다 실감했고, 이번 협업에서 저는 초기 세팅, 랜딩 페이지, 검색 페이지를 담당했습니다. api key를 노출시키지 않기 위한 방법으로는 `next.config.ts` 에 가짜 경로를 지정해주는 방식을 적용하였는데, api 호출 함수쪽에서 해당 가짜 경로의 앞부분에 불필요한 domain을 붙여두거나 query 앞에 &와 ? 를 혼동하는 등 사소한 실수들과 결합되어 원하는 요청이 안 되는데서 조금 헤맸었습니다 .. 그리고 무엇보다 `“use client”`를 쓰지 않기 위한 서버 컴포넌트를 짜는 것에서 큰 어려움을 느꼈습니다. 실시간 검색이다 보니 useEffect는 필요한데, 해당 Search 컴포넌트는 서버 컴포넌트로 쓰고 싶어서 결국 useEffect를 포함하는 하위 클라이언트 컴포넌트로 분리하였고, 또다시 따로 분리한 Input 컴포넌트는 memo로 감싸주었습니다. 또 검색어 입력에서 입력값 변경에 따라 함수를 호출하기 때문에 한 자씩 입력될 때마다 불필요하게 리렌더링 되는 것을 막기 위해 `useDebouncedCallback`으로 감싸 0.3초의 지연을 주는 디바운싱을 적용했고, 처음에는 해당 처리를 하고 나니 또 초기 데이터가 뜨지 않는 문제가 발생하여 useEffect를 초기에만 한 번 불러오는 용도로 적용하였습니다. 무한 스크롤은 다음 주차에 적용해보고자 하고, 추가로 key question을 작성하면서 더 알게 된 최적화 방식을 적용해보고 싶습니다. 알아볼수록 지금까지 써온 React는 정말 좁은 범주였음을 느끼며.. 더욱 공부해야 할 게 많다고 느낀 한 주였습니다.<br/>
+) 프로젝트 본격 개발에 앞서 유선언니와 미리 협업을 경험해 볼 수 있어 좋았습니다. 대면으로 만나서 진행하니 빠르고 유연한 소통이 가능했고, 서로 의견을 활발히 주고 받아서 더 시너지를 낼 수 있었던 것 같습니다.
  <br/>

## 💡Key Questions

### 1️⃣ React 18 버전의 변경점에 대해 설명해주세요.(+ 19 버전에 대한 추가 설명도 좋습니다)

**1. Server component (RSC) & Client component (RCC)**

기존 리액트 컴포넌트의 비동기적 data fetching은 client-server waterfall을 야기한다는 문제점이 있다. 부모 컴포넌트는 렌더링 후 필요한 데이터를 받아오기 시작하고 이 과정이 끝나기 전까지 자식 컴포넌트의 렌더링과 API 호출이 지연되며 불필요한 렌더링이 발생하기 때문이다.

이를 위해 등장한 서버 컴포넌트는 서버에서 Render을 수행하기 때문에 API를 통한 데이터 요청의 latency를 줄이고, 클라이언트에서 연속된 API 호출을 제거하여 client-server waterfall을 막는다.

**RSC의 장점**

- 자유로운 서버 리소스 접근
- 제로 번들 사이즈 컴포넌트
- 자동 코드 분할

참고: https://tech.kakaopay.com/post/react-server-components/#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8rsc%EC%99%80-%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81ssr

**2. Automatic batching**

상태 업데이트(setState)를 하나로 통합해서 배치 처리를 한 후 단일 리렌더링으로 처리함으로써 리렌더링 성능을 개선한다.

17v : 이벤트 핸들러 내부 자체에서만 상태 업데이트가 여러 번 발생할 경우 배치처리를 하여 한 번만 렌더링한다. 그 안에서 fetch()와 같이 콜백을 받아 처리하는 메소드가 있는 경우 적용되지 않는다. 따라서 state 수가 많아질수록 불필요한 리렌더링도 많이 발생한다.

18v : 이벤트 핸들러 내부에서 fetch() 함수를 활용해도 배치처리가 적용되어 핸들러 1번 작동마다 리렌더링이 1번 발생한다. but 아래와 같은 혼용 상태에서는 적용되지 않는다.

```tsx
const onClickCreateNumber = () => {
  // 핸들러 내부에서 상태 업데이트 (콜스택)
  setNumber((prev) => prev + 1);

  // fetch() 콜백함수 내부에서 상태 업데이트 (태스트 큐)
  fetch('https://jsonplaceholder.typicode.com/posts/1').then((response) => {
    setBoolean((prev) => !prev);
  });
};
```

**3. Concurrent Feature**

동시성 모드란 여러 작업을 동시에 처리하도록 우선순위를 나눠 작업 간 빠른 전환으로 동시에 수행되는 것처럼 하는 처리이다. js는 싱글 스레드 기반 언어이므로 작업을 실제로 동시에 처리하지는 않는다. 사용자 경험을 개선하는데 중요하다.

- **Suspense**

  사용자에게 보여주고 싶은 컴포넌트를 먼저 렌더링할 수 있게 하는 기능이다. 초기 렌더링 페이지를 전체가 아닌 빠르게 준비된 부분부터 보여주어 초기 렌더링 속도가 감소한다.

  ```tsx
  <Suspense fallback={<Spinner />}>
    <Comments />
  </Suspense>
  ```

  Suspense로 렌더링을 원하는 컴포넌트를 감싸면 해당 컴포넌트 렌더링이 완료되기 전까지 fallback 내부의 컴포넌트를 사용자에게 보여준다. SSR환경에서 가장 잘 작동한다.

- createRoot
  위의 배치처리와 동시성 모드는 render() 대신 쓰이는 createRoot API를 통해 지원된다. 아래와 같이 쓰인다.
  ```tsx
  // React-18v
  import React from 'react';
  import App from './App';

  import { createRoot } from 'react-dom/client';
  const container = document.getElementById('root');
  const root = createRoot(container);
  root.render(<App />);
  ```
- **Transition**
  기존의 디바운스, 쓰로틀링, setTimeout은 특정 시간을 반드시 기다려야 했으나 이를 사용하지 않고 `useTransition` 훅을 통해 `isPending` 상태값을 가져와 렌더링 결과를 분기 처리한다.
  `isPending`: state 변경 직후에도 UI를 리렌더링 하지 않고 잠시 유지하는 상태
  `startTransition` : 우선순위가 높은 상태 업데이트가 발생하면 내부에 선언한 상태 업데이트는 중단되고 클릭이나 키 입력이 끝난 후 이후에 해당 상태 업데이트가 발생한다.
  ```tsx
  const [isPending, startTransition] = useTransition({ timeoutMs: 5000 });
  ```

**4. New Hooks**

- `useId()`
  - 난수 ID를 생성하는 Hook
  - 클라이언트와 서버간의 hydration의 불일치를 피하면서 유니크 아이디를 생성하지만 key는 아니다.
  ```tsx
  function CreateId() {
    const id = useId();
    return <input id={id} type="text" />;
  }
  ```
- `useDeferredValue()`
  - 트리에서 급하지 않은 부분의 재랜더링을 지연할 수 있는 기능을 지원
  - 디바운스와 비슷하지만 고정된 지연시간이 없고 렌더링이 반영되는 시점에 지연 렌더링을 시도합니다.
    - But 주의할 점은 https://11001.tistory.com/250

### 2️⃣ nextJS 13 이후의 app routing 방식의 특징과 기능에 대해 설명해주세요.

Next.js 13 버전은 기존의 페이지 라우팅 방식에서 벗어나 새로운 App Routing 방식을 도입하여 개발자 경험과 성능을 향상시켰다. 우선 첫째로, 디렉터리를 구성하는 방식에 변화가 생겼다.

13 이전 버전에서는 pages 디렉터리를 중심으로 라우팅이 이루어졌다. pages 디렉터리 내부에 파일이나 디렉터리를 생성하면 해당 경로가 자동으로 라우팅되었다. (pages/main.js 파일을 생성하면 /main 경로로 접근하는 방식) 그러나 13에서는 새로운 app 디렉터리를 도입하여 해당 방식을 개선하였다. 우선 각 디렉터리 내에 layout.js 파일을 생성하여 해당 경로의 공통 레이아웃을 정의할 수 있고, loading.js와 error.js 파일을 통해 로딩 상태와 에러 처리를 디렉터리별로 관리할 수 있으며, 파일 상단에 'use client'; 지시어를 사용하여 클라이언트 컴포넌트를 정의할 수도 있다.

Next.js 13에서는 기본적으로 서버 컴포넌트(서버에서 렌더링되며, 비동기 함수로 정의 가능)를 사용하며, 필요에 따라 클라이언트 컴포넌트('use client'; 지시어를 사용하여 정의하며, 브라우저에서 실행됨)를 정의한다. 서버 컴포넌트에서는 데이터베이스 접근, API 호출 등 서버 측 로직을 직접 구현할 수 있다. 이를 통해 서버리스 함수를 작성할 수 있으며, 별도의 백엔드 서버 없이도 백엔드 로직을 구현할 수 있다.

또한, 패러랠 라우트(동일한 레벨에서 여러 경로를 동시에 렌더링할 수 있도록 하는 기능)와 인터셉팅 라우트(기존의 네비게이션 흐름을 가로채어 다른 UI를 렌더링할 수 있게 함)도 구현 가능하다. 각각 [[]]나 (())를 사용하여 라우트를 정의하면 된다.

SSR은 서버 사이드 렌더링으로, 요청 시점에 서버에서 HTML을 생성하여 클라이언트에게 전달하는 방식이다. Next.js에서는 기본적으로 페이지 컴포넌트를 비동기 함수로 정의하고, 내부에서 데이터를 패칭하여 SSR을 구현한다. SSG는 빌드 시점에 HTML을 생성하여 CDN에 배포하는 방식으로, 빠른 응답 속도와 캐싱에 유리하다는 장범이 있다. Next.js에서 이걸 구현하려면 getStaticProps나 generateStaticParams를 사용하면 된다.

### 3️⃣ vercel, netlify 같은 호스팅 플랫폼의 특징과 내부 구현 원리에 대해 설명해주세요(+ aws의 스토리지와 인스턴스 등 생태계에 대해서도 알려주세요)

**1) Vercel**

Next.js의 개발사로, CI/CD 파이프라인을 자동화하여 Git에서 커밋이 발생할 때마다 변경된 내용을 자동으로 빌드하고 배포한다.

1. **서버리스 기능**: 클라이언트 요청에 따라 서버리스 함수가 트리거된다. 이 함수는 AWS Lambda 같은 서버리스 플랫폼을 기반으로, 필요할 때마다 인스턴스를 생성하여 실행하고, 처리가 끝나면 인스턴스를 제거한다.
2. **캐싱과 엣지 네트워크**: 전 세계에 분산된 CDN을 통해 정적 콘텐츠를 캐싱하여 빠르게 제공하고, 데이터베이스나 API 호출이 필요한 경우에는 엣지 네트워크를 사용해 지연 시간을 최소화한다.

**2) Netlify**

Jamstack(Javascript, API, Markup) 구조의 프로젝트에 최적화되어 있으며, 정적 웹사이트 생성과 CDN 배포를 기본으로 합니다.

1. **CI/CD 파이프라인**: Git 저장소에 변경이 발생하면 자동으로 빌드와 배포를 수행하고, 사용자 정의 가능한 빌드 스크립트를 통해 애플리케이션의 복잡한 빌드 과정을 유연하게 설정할 수 있다.
2. **서버리스 함수 지원**: Netlify Functions라는 서버리스 기능을 통해, 요청이 발생할 때만 함수를 실행하는 방식으로 리소스를 절약한다.
3. **내부 CDN 및 엣지 네트워크**: 전 세계 CDN 네트워크를 통해 정적 자산을 빠르게 제공, 특정 페이지나 API 호출을 위한 엣지 네트워크 최적화로 성능을 높인다.

**3) AWS 생태계**

1. **AWS 스토리지**: 안정적이고 확장성 높은 오브젝트 스토리지 서비스. 정적 웹사이트 호스팅, 백업, 데이터 아카이빙 등에 많이 사용된다. 정적 파일을 S3에 업로드하고 CloudFront CDN과 연계하면 빠른 콘텐츠 전송이 가능하다.
2. **EC2 인스턴스**: 가상 서버 인스턴스. 운영 체제와 소프트웨어를 설치하여 애플리케이션을 호스팅할 수 있고 서버를 확장하거나 줄일 수 있습니다.
3. **AWS Lambda (서버리스 컴퓨팅)**: Vercel과 Netlify의 서버리스 함수와 유사하게 특정 이벤트에 따라 함수가 실행된다.
4. **데이터베이스와 API 서비스**: RDS나 DynamoDB 등의 데이터베이스를 제공하고 API Gateway를 통해 서버리스 API를 통해 유연한 아키텍처 구성이 가능하다.
